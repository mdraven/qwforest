
11 августа 2011

Утилитка для генерации леса из картинки.


@o Makefile @{
CC=gcc
MYWEB=~/MyWork/myweb/myweb.py
LDFLAGS+=@<Ldflags@>
CFLAGS+=@<Cflags@>

qwforest: main.o
	$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@

main.o: main.c
	$(CC) $(CFLAGS) -c $<

main.c: main.w
	$(MYWEB) $^
@}


@o main.c @{
@<License@>
@<Headers@>
@<Structs@>

int main(int argc, char **argv) {
	@<Variables@>

	@<Check params@>
	@<Load image@>
	@<Check image@>
	@<Allocate trees@>
	@<Gen trees@>
	@<Print trees@>
	@<Free@>
	return 0;
}@}

@d Check params @{@-
if(argc < 7) {
	fprintf(stdout, "usage: %s input_image width depth trees-per-line repeat-last-lines types-of-tree\n", argv[0]);
	exit(1);
}
width = atoi(argv[2]);
depth = atoi(argv[3]);
trees_per_line = atoi(argv[4]);
repeat = atoi(argv[5]);
types_of_tree = atoi(argv[6]);
@}
Входная картинка, ширина и глубина между деревьями, число деревьев на линию,
	сколько нижних рядов повторить сверху, количество типов деревьев.
Нижние ряды повторяются сверху, чтобы проще было образовать кольцо.
repeat-last-lines - число пикселов на картинке.

@d Headers @{@-
#include <stdio.h>
#include <stdlib.h>@}

@d Variables @{@-
int width, depth, trees_per_line, repeat, types_of_tree;@}

Загрузим картинку:
@d Variables @{
SDL_Surface *img;@}

@d Load image @{
img = IMG_Load(argv[1]);
if(img == 0) {	
	fprintf(stdout, "Can't load file %s\n", argv[1]);
	exit(1);
}
@}

@d Free @{
SDL_FreeSurface(img);@}

@d Headers @{
#include <SDL.h>
#include <SDL_image.h>@}

@d Cflags @{@-
`sdl-config --cflags`@}

@d Ldflags @{@-
`sdl-config --libs` -lSDL_image@}

Проверим глубину цвета картинки:
@d Check image @{@-
if(img->format->BytesPerPixel != 1) {
	fprintf(stdout, "Image file should be grayscale\n");
	exit(1);
}
@}

@d Allocate trees @{@-
acc_num = (img->h/depth) * trees_per_line;
acc = malloc(sizeof(Tree) * acc_num);
if(acc == NULL) {
	fprintf(stdout, "Can't allocate memory\n");
	exit(1);
}
@}

@d Free @{@-
free(acc);
@}

@d Variables @{
Tree *acc;
int acc_num;@}

@d Structs @{
typedef struct {
	int x;
	int y;
	unsigned int type;
} Tree;
@}

Выведем список деревьев:
@d Gen trees @{@-
if(SDL_LockSurface(img) != 0) {
	fprintf(stdout, "Can't lock surface\n");
	exit(1);
}

srand(time(NULL));

@<Gen process@>

SDL_UnlockSurface(img);
@}

Генерируем лес снизу вверх:
@d Gen process @{@-
{
	int i, j;
	int p = 0;
	char *f;

	f = malloc(img->w);
	if(f == NULL) {
		fprintf(stdout, "Can't allocate memory\n");
		exit(1);
	}

	for(i = img->h-1; i > -1; i-=depth) {
			@<Gen trees_per_line@>
	}

	free(f);
}
@}
f - массив флагов. Если флаг равен 0, то мы можем выбрать дерево
	в этой точке, если 1, то не можем.

@d Gen trees_per_line @{@-
do {
	bzero(f, img->w);

	for(j = 0; j < trees_per_line; j++) {
	 	int x;
	 	int k;
	 	int t1, t2;
	 
	 	@<Fill zero pixels@>
		@<Check free flags@>
	 	@<Choose point for tree@>
	 	@<Fill flags from -width to +width@>
	 
	 	acc[p+j].x = x;
	 	acc[p+j].y = i;
	 	acc[p+j].type = ((unsigned char*)img->pixels)[i*img->w + x] % types_of_tree;
	}
} while(j != trees_per_line);

p += trees_per_line;
@}
do...while для организации "рестарта", если свободные флаги закончились.

Если цвет пиксела 0, то там дорога и нет дерева, поэтому установим
флаг в 1:
@d Fill zero pixels @{@-
for(k = 0; k < img->w; k++)
	if(((unsigned char*)img->pixels)[i*img->w + k] == 0)
		f[k] = 1;
@}

Проверяем наличие свободных флагов.
Если их нет, то разрываем for и возвращаемся в while:
@d Check free flags @{
for(k = 0; k < img->w; k++)
	if(f[k] == 0)
		break;
if(k == img->w)
	break;
@}

Выберем доступную для дерева точку:
@d Choose point for tree @{
do {
	x = rand()%img->w;
} while(f[x] != 0);
@}

Заполним флаги от выбранной точки 'x' в обе стороны на width.
Этим мы добъёмся того, что деревья будут отстоять друг от друга на width:
@d Fill flags from -width to +width @{
t1 = x - width < 0 ? 0 : x - width;
t2 = x + width > img->w ? img->w : x + width;
for(k = t1; k < t2;	k++)
	f[k] = 1;
@}

@d Headers @{
#include <math.h>
#include <string.h>
#include <stdlib.h>@}

@d Ldflags @{@-
 -lm@}

@d Print trees @{
printf("/* File was generated by qwforest */\n");
printf("static const Tree trees[] = {\n");
{
	int i;
	@<Print repeat part@>
	@<Print other part@>
}
printf("};\n");
@}

@d Print repeat part @{@-
for(i = (repeat/depth) * trees_per_line - 1; i > -1; i--) {
	int ind = acc_num - i - 1;

	//if(acc[ind].y > repeat)
	//	continue;

	printf("\t{%d, %d, %d},\n", acc[ind].x, acc[ind].y+img->h, acc[ind].type);
}
@}
Печатает последние (repeat/depth) блоков высотой depth.

@d Print other part @{@-
for(i = 0; i < acc_num; i++)
	printf("\t{%d, %d, %d},\n", acc[i].x, acc[i].y, acc[i].type);
@}


@d License @{@-
/*
 * qwforest - helper for creating forest files
 * Copyright (C) 2011 Iljasov Ramil
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@}
