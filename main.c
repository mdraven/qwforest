
/*
 * qwforest - helper for creating forest files
 * Copyright (C) 2011 Iljasov Ramil
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <stdlib.h>
#include <SDL.h>
#include <SDL_image.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
	int x;
	int y;
	unsigned int type;
} Tree;


int main(int argc, char **argv) {
	int width, depth, trees_per_line, repeat, types_of_tree;
	SDL_Surface *img;
	Tree *acc;
	int acc_num;

	if(argc < 7) {
		fprintf(stdout, "usage: %s input_image width depth trees-per-line repeat-last-lines types-of-tree\n", argv[0]);
		exit(1);
	}
	width = atoi(argv[2]);
	depth = atoi(argv[3]);
	trees_per_line = atoi(argv[4]);
	repeat = atoi(argv[5]);
	types_of_tree = atoi(argv[6]);

	
	img = IMG_Load(argv[1]);
	if(img == 0) {	
		fprintf(stdout, "Can't load file %s\n", argv[1]);
		exit(1);
	}

	if(img->format->BytesPerPixel != 1) {
		fprintf(stdout, "Image file should be grayscale\n");
		exit(1);
	}

	acc_num = (img->h/depth) * trees_per_line;
	acc = malloc(sizeof(Tree) * acc_num);
	if(acc == NULL) {
		fprintf(stdout, "Can't allocate memory\n");
		exit(1);
	}

	if(SDL_LockSurface(img) != 0) {
		fprintf(stdout, "Can't lock surface\n");
		exit(1);
	}
	
	srand(time(NULL));
	
	{
		int i, j;
		int p = 0;
		char *f;
	
		f = malloc(img->w);
		if(f == NULL) {
			fprintf(stdout, "Can't allocate memory\n");
			exit(1);
		}
	
		for(i = img->h-1; i > -1; i-=depth) {
				do {
					bzero(f, img->w);
				
					for(j = 0; j < trees_per_line; j++) {
					 	int x;
					 	int k;
					 	int t1, t2;
					 
					 	for(k = 0; k < img->w; k++)
					 		if(((unsigned char*)img->pixels)[i*img->w + k] == 0)
					 			f[k] = 1;
				
						
						for(k = 0; k < img->w; k++)
							if(f[k] == 0)
								break;
						if(k == img->w)
							break;
				
					 	
					 	do {
					 		x = rand()%img->w;
					 	} while(f[x] != 0);
				
					 	
					 	t1 = x - width < 0 ? 0 : x - width;
					 	t2 = x + width > img->w ? img->w : x + width;
					 	for(k = t1; k < t2;	k++)
					 		f[k] = 1;
				
					 
					 	acc[p+j].x = x;
					 	acc[p+j].y = i;
					 	acc[p+j].type = ((unsigned char*)img->pixels)[i*img->w + x] % types_of_tree;
					}
				} while(j != trees_per_line);
				
				p += trees_per_line;
	
		}
	
		free(f);
	}
	
	
	SDL_UnlockSurface(img);

	
	printf("/* File was generated by qwforest */\n");
	printf("static const Tree trees[] = {\n");
	{
		int i;
		for(i = (repeat/depth) * trees_per_line - 1; i > -1; i--) {
			int ind = acc_num - i - 1;
		
			//if(acc[ind].y > repeat)
			//	continue;
		
			printf("\t{%d, %d, %d},\n", acc[ind].x, acc[ind].y+img->h, acc[ind].type);
		}
	
		for(i = 0; i < acc_num; i++)
			printf("\t{%d, %d, %d},\n", acc[i].x, acc[i].y, acc[i].type);
	
	}
	printf("};\n");

	
	SDL_FreeSurface(img);free(acc);

	return 0;
}